\section{Reverse engineering the Raspberry Pi camera}\label{pihack}
The Raspberry Pi camera is for the project, as it is readily available at the university. This means it will be easy and quick to get a new camera, if it should stop working.

Unfortunately, there is currently no complete documentation available for the camera, so most of the register setup must be done by reverse engineering the camera and the interaction between the Raspberry Pi and the camera.

The schematic for the camera module is not being provided by the Raspberry Pi Foundation, so the first step is to determine the pinout of the camera. Most of it can be found in the schematic for the Raspberry Pi, see \autoref{pi_cam_connector}

%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.85\textwidth]{figures/picam_pinout.png}
%	\caption{Pinout of the Raspberry Pi camera connector [source: \url{http://www.rs-online.com/designspark/electronics/knowledge-item/r-pi-ffc-connectors}]}
%	\label{pi_cam_connector}
%\end{figure}

The majority of these connections can be recognized from the CSI-2 specifications, and a preliminary table can be put together of the camera pinout. Only two connections remains unknown, see \autoref{csi_pinout}.
\begin{table}[H]
\centering 
\scalebox{0.8}{
\begin{tabular}{|l|l|l|}
\hline
\textbf{Pin number}         & \textbf{Name}      & \textbf{Description}                                    \\ \hline
1, 4, 7 and 10 & GND       & Supply Ground                                  \\ \hline
2              & CAM1\_DN0 & \multirow{2}{*}{D-PHY Differential Data Lane 0} \\ \cline{1-2}
3              & CAM1\_DP0 &                                                \\ \hline
5              & CAM1\_DN1 & \multirow{2}{*}{D-PHY Differential Data Lane 1} \\ \cline{1-2}
6              & CAM1\_DP1 &                                                \\ \hline
8              & CAM1\_CN  & \multirow{2}{*}{D-PHY Differential Clock}       \\ \cline{1-2}
9              & CAM1\_CP  &                                                \\ \hline
11             & CAM\_GPIO & Undocumented                                   \\ \hline
12             & CAM\_CLK  & Undocumented                                   \\ \hline
13             & SCL0      & \multirow{2}{*}{\iic bus}                       \\ \cline{1-2}
14             & SDA0      &                                                \\ \hline
15             & +3V3      & Supply 3.3V                                    \\ \hline
\end{tabular}}
\caption{Camera pinout}
\label{csi_pinout}
\end{table}

As the pinout is now known, a breakout board can be made to connect between the camera and the Raspberry Pi. The board provides easy access to the high speed data lines via BNC connectors, and pinheaders for listening on the \iic bus.

The PCB can be seen on \autoref{camerabreakout}.

%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.60\textwidth]{figures/pihack_board.jpg}
%	\caption{Breakout board for monitoring camera signals.}
%	\label{camerabreakout}
%\end{figure}

Now step two can begin, the actual reverse engineering. The Raspberry Pi will be commanded to take pictures in various resolution, while the \iic bus is monitored with an oscilloscope, a Rigol DS1102E. This oscilloscope provides a "Deep memory"-Mode, where up to a million samples can be captured, and afterwards saved as a .csv file. The test setup can be seen on \autoref{hack_setup}

%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.60\textwidth]{figures/testsetup_pihack.jpg}
%	\caption{Test setup for monitoring the \iic bus}
%	\label{hack_setup}
%\end{figure}

A screenshot of a capture can be seen on \autoref{i2ccap}. As seen on the screenshot, the Raspberry Pi sends a few short data burst, followed by a long burst. The short bursts contains very little data, and are easily decoded manually, by watching the waveforms.

A zoomed in view of the initial short burst can be seen on \autoref{i2czoom}.

%\begin{figure}[H]
%	\centering
%	\begin{subfigure}{.45\textwidth}
%		\centering
%		\includegraphics[width=\linewidth]{longburst.png}
%		\caption{Captured \iic data}
%		\label{i2ccap}
%	\end{subfigure}
%	\hfill
%	\begin{subfigure}{.45\textwidth}
%		\centering
%		\includegraphics[width=\linewidth]{zoomedburst.png}
%		\caption{Zoomed in short burst}
%		\label{i2czoom}
%	\end{subfigure}\\
%	\caption{Image captures containing \iic burst from the setup on \autoref{hack_setup}}
%	\label{I2C_burst}
%\end{figure}

Decoding a couple of transfers in this data results in the following bit sequences:

\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
\hline 
\textbf{Binary:} & 011 0110 & 0 & 0 & 0000 0001 & 0 & 0000 0000 & 0 & 0000 0000 & 0 \\ 
\hline 
\textbf{Hex:} & 0x36 & 0 & 0 & 0x01 & 0 & 0x00 & 0 & 0x00 & 0 \\ 
\hline 
\textbf{Description:} & address & write & ack & data & ack & data & ack & data & ack \\ 
\hline 
\end{tabular} 

\textbf{Translation:} "Write 0x01, 0x00 and 0x00 to \iic address 0x36"


\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline 
\textbf{Binary:} & 011 0110 & 0 & 0 & 0000 0001 & 0 & 0000 0000 & 0 \\ 
\hline 
\textbf{Hex:} & 0x36 & 0 & 0 & 0x01 & 0 & 0x00 & 0 \\ 
\hline 
\textbf{Description:} & address & write & ack & data & ack & data & ack \\ 
\hline 
\end{tabular}

\textbf{Translation:} "Write 0x01 and 0x00 to \iic address 0x36"\\


\begin{tabular}{|l|c|c|c|c|c|}
\hline 
\textbf{Binary:} & 011 0110 & 1 & 0 & 0000 0000 & 1 \\ 
\hline 
\textbf{Hex:} & 0x36 & 1 & 0 & 0x00 & 1 \\ 
\hline 
\textbf{Description:} & address & read & ack & data & ack \\ 
\hline 
\end{tabular}

\textbf{Translation:} "Read from \iic address 0x36" (0x00 is read from the slave)\\


\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|}
\hline 
\textbf{Binary:} & 011 0110 & 0 & 0 & 0000 0001 & 0 & 0000 0011 & 0 & 0000 0001 & 0 \\ 
\hline 
\textbf{Hex:} & 0x36 & 0 & 0 & 0x01 & 0 & 0x03 & 0 & 0x01 & 0 \\ 
\hline 
\textbf{Description:} & address & write & ack & data & ack & data & ack & data & ack \\ 
\hline 
\end{tabular} 

\textbf{Translation:} "Write 0x01, 0x03 and 0x01 to \iic address 0x36" \\

According to \citep[p. 77]{picam_datasheet} \iic slave address of the camera is 0x6C for writes, and 0x6D for reads. As the \iic standard calls for 7 bit addresses, followed by a read/write bit, looking at the provided addresses in binary gives the answer why the decoded address is different from what the datasheet claims:
\begin{center}
\begin{tabular}{|l|c|c|}
\hline 
\textbf{Hex:} & 0x6C & 0x6D \\ 
\hline 
\textbf{Binary:} & 0110 1100 & 0110 1101 \\ 
\hline 
\end{tabular} 
\end{center}

The datasheet is simply interpreting the read/write bit as part of the address.\\

According to \citep[p. 23]{picam_datasheet}, a software sleep can be commanded, by writing 0x00 to register address 0x0100. This matches the first transfer. The first two bytes are the register address, and the last is the data to write.

Starting the configuration with a sleep command makes sense - there is no need for the camera to be active until it has been fully configured. The next two transfers reads back the written data from the last transfer. Why this is done is unknown, but it might be for making sure the camera is working correctly.

Now that the transfer format, has been undestood, it is clear that the last of the four transfers must be "Open register 0x0103, and write 0x01". According to the datasheet, this is the command to reset the sensor, again something which makes sense to do during initialization, to make sure all registers are in a well known state.

The long databurst now needs to be decoded. Because of the large amount of data, this will need to be automated. The oscilloscope can save the captured data to a \gls{.csv} file.

Now Sigrok, an open source signal analysis software suite will be used (\url{http://www.sigrok.org}). This package contains a tool for reading a .csv file from a logic analyser, and finding \iic packets. As the data has been captured with an oscilloscope, and not a logic analyzer, the data will need to be reformatted in a way sigrok understands.

The oscilloscope saves the captured data as the voltages of the two channels, together with a timestamp. Sigrok expects only 1's and 0's. The conversion from voltages to binary values is easily done using Matlab. The data is imported, and the clock and data channels identified, see \autoref{matlab1}

%\begin{figure}[H]
%	\centering
%	\includegraphics[width=0.7\textwidth]{figures/matlab1.png}
%	\caption{Importing oscilloscope data.}
%	\label{matlab1}
%\end{figure}
\clearpage
The voltages can now be converted to 1's and 0's, and saved as a new .csv file using the following commands:
\begin{lstlisting}[caption={Matlab commands}, language=Matlab, label=matlab2]
CH1(CH1<2.7)=0
CH2(CH2<2.7)=0
CH1(CH1>2.6)=1
CH2(CH2>2.6)=1
DATA = [CH1, CH2]
csvwrite('i2cdata.csv',DATA)
\end{lstlisting}

The generated .csv file can now be processed by Sigrok. This will analyse the data and create a text file with the \iic transfers, see \autoref{i2c1}.

Now that the actual \iic data has been obtained, it has to be converted to a format that can be easily included in the microcontroller software. To do this, a small C program is written, that takes the sigrok data in and outputs a C header file, containing an array with the data to be written to the camera, see \autoref{i2c2}


%\begin{figure}[H]
%	\centering
%	\begin{subfigure}{.45\textwidth}
%		\centering
%		\includegraphics[width=\linewidth]{i2c1.png}
%		\caption{Sigrok output data}
%		\label{i2c1}
%	\end{subfigure}
%	\hfill
%	\begin{subfigure}{.45\textwidth}
%		\centering
%		\includegraphics[width=\linewidth]{i2c2.png}
%		\caption{Generated C header file}
%		\label{i2c2}
%	\end{subfigure}\\
%		\caption{Screenshots describing output data and the generated C header file}
%	\label{screenshot_computer}
%\end{figure}



The above procedure with the decoding of \iic packages and generation of registers based on these is repeated for the relevant image resolutions, to get the register set for each. An example of such a register set can be seen in \autoref{idiocrazy}.

\begin{table}[H]
\centering
\scalebox{0.9}{
\begin{tabular}{|c|l|c|c|}
\hline
\textbf{Register Address} & \textbf{Description}                                                                                                                                                                                                                                                     & \textbf{Default data} & \textbf{Configured data} \\ \hline
\multirow{7}{*}{0x3034}   & \multirow{7}{*}{\begin{tabular}[c]{@{}l@{}}SC\_CMMN\_PLL\_CTRL0:\\ \\ Bit{[}6:4{]}: pll\_charge\_pump\\ Bit{[}3:0{]}: mipi\_bit\_mode\\                0000: 8 bit mode\\                0001: 10 bit mode\\                Others: Reserved to future use\end{tabular}} & \multirow{7}{*}{0x1A} & \multirow{7}{*}{0x1A}    \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\
                          &                                                                                                                                                                                                                                                                          &                       &                          \\ \hline
\end{tabular}
}
\caption{Example of a register description from the datasheet. Note that the Default configuration is "Reserved to future use", which is rather odd.}
\label{idiocrazy}
\end{table}


With the register setups at hand, the camera can now be powered on without the Raspberry Pi. During the testing, an MSP430 MCU development board is used to send the \iic data, as it is a simple architecture to get up and running, and is configured for 3.3V operation just like the camera. An Arduino could have been used, but this would require \iic level shifters, as the Arduino uses 5V logic levels.

As an initial test, the sleep command is sent to the camera and then read back. Unfortunately, the camera ignores the \iic transfer, and appears completely dead.

Probing around the camera board with the oscilloscope, it turns out that the oscillator providing the camera clock is not running. This must be caused by one of the two undocumented pins on the camera board. It is presumed that the CAM\_CLK pin could be responsible for activating the oscillator, and pulling this pin to a logic high, in fact makes in oscillator starts up. At the same time an LED on the camera board lights up.

With the oscillator now running, the sleep command is sent to the camera again, again without result.
According to \citep[p. 23: reset]{picam_datasheet}, using a hardware reset pin is recommended, even though the camera supports software reset.

As it is very likely that the camera board designers have read the same section, it is almost certain that the last pin (CAM\_GPIO) controls this.
Pulling this pin to a logic high, the camera starts responding to \iic commands.\\
Sending one of the captured data bursts causes the CSI bus to become active and start streaming data. The camera is now ready for connecting to the MIPI bridge in the FPGA.
